# [4단원] 자료구조: 코딩 테스트의 기초 체력

> **강의 목표**
> * 배열과 리스트의 차이를 이해하고 파이썬의 `list`를 능숙하게 다룹니다.
> * **구간 합(Prefix Sum)**을 통해 시간 복잡도를 획기적으로 줄이는 방법을 배웁니다.
> * 문제 풀이의 4단계(분석-손풀기-슈도코드-구현)를 익힙니다.

---

## 4-1. 배열과 리스트

### 1. 배열(Array) vs 리스트(List)
* **배열:** 크기가 고정되어 있고, 인덱스로 빠르게 접근 가능하지만 데이터 삽입/삭제가 어렵습니다.
* **리스트:** 크기가 가변적이고, 데이터 삽입/삭제가 비교적 자유롭습니다.
* **파이썬의 `list`:** 파이썬은 배열과 리스트의 장점을 합친 형태입니다. 인덱스 접근도 빠르고(`O(1)`), 크기도 자유롭게 변합니다.

### 2. 문제 풀이 4단계 & 슈도코드(Pseudo-code) 작성법
책에서 강조하는 문제 해결 프로세스입니다. 특히 **슈도코드**는 코드를 작성하기 전 **'논리적 설계도'**를 그리는 과정입니다.

1.  **문제 분석하기:** 시간 복잡도($N$의 크기 확인), 변수 범위, 알고리즘 선택.
2.  **손으로 풀어보기:** 예제 입력을 보며 직접 그려보거나 계산해 봅니다.
3.  **슈도코드 작성하기:** 문법에 얽매이지 않고 **'사람의 언어'**로 로직을 적습니다.
    * *예시:* `input()` 대신 `N을 입력받는다`
    * *예시:* `for i in range(N)` 대신 `N번 만큼 반복한다`
4.  **코드 구현하기:** 슈도코드를 실제 파이썬 문법으로 바꿉니다.

> **💡 슈도코드 팁:**
> 처음엔 한글로 주석을 달듯이 순서대로 적어보세요. "입력을 받고 -> 리스트에 넣고 -> 반복문 돌면서 -> 조건 맞으면 출력한다" 이렇게 흐름만 잡으면 됩니다.
---
### [실전 문제] 11720번: 숫자의 합
> **문제 내용** > N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.
>
> **입력** > 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백 없이 주어진다.
>
> **출력** > 입력으로 주어진 숫자 N개의 합을 출력한다.

**예제 입력 1**
```text
1
1
```
**예제 출력 1**
```text
1
```
**예제 입력 2**
```text
5
54321
```
**예제 출력 2**
```text
15
```
**예제 입력 3**
```text
25
7000000000000000000000000
```
**예제 출력 3**
```text
7
```
**예제 입력 4**
```text
11
10987654321
```
**예제 출력 4**
```text
46
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어

* 입력받은 숫자들을 문자열(String)로 취급하면 리스트처럼 한 글자씩 접근할 수 있습니다.
* 파이썬의 형 변환(int(), str())을 활용합니다.

### 📝 슈도코드(Pseudo-code)
```text
1. N을 입력받는다.
2. 숫자들을 문자열 형태(numbers)로 입력받는다.
3. 합계를 저장할 변수 total을 0으로 초기화한다.
4. numbers의 각 자리수(num)에 대하여:
    4-1. 문자인 num을 정수형으로 변환하여 total에 더한다.
5. total을 출력한다.
```
### 💻 정답 코드 ###
```python
N = int(input())
numbers = input()
total = 0

for num in numbers:
    total += int(num)  # 문자 '5'를 정수 5로 변환하여 더함

print(total)
```
### 🚀 파이썬다운 풀이 (심화) ###
```python
input() # N은 안 쓰므로 버림
print(sum(map(int, input()))) 
# 입력받은 문자열을 정수 리스트로 매핑하여 한 번에 합침
```
</details>

---

### [실전 문제] 1546번: 평균
> **문제 내용** > 세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 `점수/M*100`으로 고쳤다.
> 예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 `50/70*100`이 되어 71.43점이 된다.
> 세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.
>
> **입력** > 첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.
>
> **출력** > 첫째 줄에 새로운 평균을 출력한다.

**예제 입력 1**
```text
3
40 80 60
```
**예체 출력 1**
```text
75.0
```
**예제 입력 2**
```text
3
10 20 30
```
**예체 출력 2**
```text
66.666667
```
**예제 입력 3**
```text
4
1 100 100 100
```
**예제 출력 3**
```text
75.25
```
<details><summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어
* 단순히 문제에 나온 식대로 모든 점수를 변환한 뒤 평균을 구해도 되지만, 수식의 성질을 이용하면 더 간단합니다.
* $(A / M \times 100 + B / M \times 100 + C / M \times 100) / 3$
* $= (A + B + C) \times 100 / M / 3$
* 즉, (모든 점수의 합) * 100 / 최댓값 / 과목 수 를 계산하면 됩니다.

### 📝 슈도코드(Pseudo-code)
```text
1. 과목 수 N을 입력받는다.
2. 점수들을 리스트(scores)로 입력받는다.
3. scores에서 최댓값(M)을 찾는다.
4. scores의 모든 항목의 합(Sum)을 구한다.
5. 결과 = Sum * 100 / M / N 공식을 적용한다.
6. 결과를 출력한다.
```

### 💻 정답 코드 ###
```python
N = int(input())
scores = list(map(int, input().split()))
M = max(scores)
Sum = sum(scores)

# 변환된 평균 구하기
print(Sum * 100 / M / N)
```
</details>

## 4-2. 구간 합 (Prefix Sum)

### 1. 구간 합을 왜 써야 할까? (시간 복잡도)
N개의 숫자가 있을 때 "i번째부터 j번째까지의 합을 구하라"는 질문을 M번 받는다고 가정해 봅시다.

* **일반적인 방법:** 질문을 받을 때마다 `for` 문으로 더하기.
    * 최악의 경우 매번 N개를 더해야 함.
    * 시간 복잡도: **$O(N \times M)$**
    * 데이터가 10만 개, 질의가 10만 번이면? -> **100억 번 연산 (시간 초과!)**

* **구간 합 배열 사용:** 미리 합계 배열을 만들어 둠.
    * 만드는 데 $O(N)$, 답하는 데 $O(1)$.
    * 시간 복잡도: **$O(N + M)$**
    * 데이터가 많을수록 압도적으로 빠릅니다.

### 2. 합 배열(S) 정의와 공식
* **합 배열 S[i]:** 0번째부터 i번째까지의 모든 수의 합.
    $$S[i] = S[i-1] + A[i]$$
* **구간 합 구하기 (i ~ j):** j까지의 합에서 i-1까지의 합을 빼면 됩니다.
    $$Sum(i, j) = S[j] - S[i-1]$$

---
### [실전 문제] 11659번: 구간 합 구하기 4
> **문제 내용** > 수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.
>
> **입력** > 첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.
>
> **출력** > 총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.

**예제 입력**
```text
5 3
5 4 3 2 1
1 3
2 4
5 5
```
**예제 출력**
```text
12
9
1
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어
* 무조건 sys.stdin.readline을 사용해야 합니다. (데이터가 많음)
* 입력받은 수 리스트 $A$를 바탕으로 합 배열 $S$를 먼저 만듭니다.
* $S$ 배열은 계산 편의를 위해 맨 앞에 0을 추가해두면 좋습니다. (1번째부터 시작하는 문제 인덱스와 맞추기 위함)

### 📝 슈도코드
```text
1. N(데이터 개수), M(질의 개수) 입력받기
2. 숫자 리스트 A 입력받기
3. 합 배열 S 선언 (0번째 인덱스는 0으로 초기화)
4. for k를 1부터 N까지 반복:
    4-1. S[k] = S[k-1] + A의 해당 숫자
    4-2. S에 추가
5. for _ in range(M):
    5-1. 구간 i, j 입력받기
    5-2. S[j] - S[i-1] 출력
```

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
nums = list(map(int, input().split()))

# 합 배열(Prefix Sum) 만들기
prefix_sum = [0]
temp = 0
for i in nums:
    temp += i
    prefix_sum.append(temp) 
    # prefix_sum = [0, 5, 9, 12, 14, 15]가 됨

# 구간 합 구하기
for _ in range(M):
    i, j = map(int, input().split())
    # i번째부터 j번째까지의 합 = S[j] - S[i-1]
    print(prefix_sum[j] - prefix_sum[i-1])
```
</details>

### [실전 문제] 11660번: 구간 합 구하기 5 (2차원)
> **문제 내용** > N×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.
>
> **입력** > 표의 크기 N, 합을 구해야 하는 횟수 M. 그 다음 N개의 줄에 표의 숫자가 주어짐. 그 다음 M개의 줄에 x1, y1, x2, y2가 주어짐.
>
> **출력** > 각 줄마다 구간 합 출력.

<details><summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어 (2차원 구간 합 공식)
2차원 배열 $D[i][j]$를 $(1, 1)$부터 $(i, j)$까지의 사각형 합이라고 정의하면:

1.  **합 배열 채우기:**
    $$D[i][j] = D[i][j-1] + D[i-1][j] - D[i-1][j-1] + A[i][j]$$
    *(왼쪽 합 + 위쪽 합 - 중복된 대각선 합 + 현재 값)*
    
2.  **구간 합 구하기:**
    $$(x1, y1) \sim (x2, y2) \text{ 합} =$$
    $$D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1]$$
    *(전체 큰 사각형 - 위쪽 영역 - 왼쪽 영역 + 두 번 뺀 겹치는 영역)*

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
A = [[0] * (N + 1)] # 원본 배열 (인덱스 1부터 시작하기 위해 패딩)

for i in range(1, N + 1):
    row = list(map(int, input().split()))
    for j in range(1, N + 1):
        A[i][j] = row[j-1]

# 합 배열 D 만들기
D = [[0] * (N + 1) for _ in range(N + 1)]

for i in range(1, N + 1):
    for j in range(1, N + 1):
        D[i][j] = D[i][j-1] + D[i-1][j] - D[i-1][j-1] + A[i][j]

# 질의 처리
for _ in range(M):
    x1, y1, x2, y2 = map(int, input().split())
    result = D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1]
    print(result)
```
</details>

### [실전 문제] 10986번: 나머지 합
> **문제 내용** > 수 N개 $A_1, A_2, ..., A_N$이 주어진다. 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.
> 즉, $(A_i + ... + A_j) \% M = 0$ 인 $(i, j)$ 쌍의 개수를 구하시오.
>
> **입력** > N(1 ≤ N ≤ 10^6), M(2 ≤ M ≤ 10^3). 둘째 줄에 N개의 수.
>
> **출력** > 나누어 떨어지는 구간의 개수.

<details>
<summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어 (수학적 접근)
이 문제는 $O(N^2)$으로 풀면 시간 초과입니다. 구간 합 배열의 **나머지** 성질을 이용해야 합니다.

1.  구간 합의 나머지가 0인 경우: $S[i] \% M == 0$ 이면 그 자체로 정답 카운트.
2.  나머지가 같은 인덱스끼리 뺀 경우:
    * $S[j] \% M = k$ 이고 $S[i-1] \% M = k$ 라면,
    * $(S[j] - S[i-1]) \% M = (k - k) \% M = 0$
    * 즉, **나머지가 같은 인덱스 2개를 뽑으면** 그 사이 구간 합은 M으로 나누어 떨어집니다.

### 📝 풀이 순서
1. 합 배열 $S$를 만든다.
2. $S$의 모든 값을 $M$으로 나눈 나머지로 업데이트한다.
3. 나머지가 같은 인덱스의 개수를 센다. (예: 나머지가 1인 게 3개면, $_3C_2$)
4. 조합 공식($_nC_2 = n(n-1)/2$)을 이용해 정답을 더한다.

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
A = list(map(int, input().split()))

S = 0 # 합 변수
remainder = [0] * M # 나머지 개수 저장 (0 ~ M-1)

for i in range(N):
    S += A[i]
    remainder[S % M] += 1 # 합의 나머지 카운트

answer = remainder[0] # 나머지가 0인 구간은 그 자체로 정답

# 나머지가 같은 것 중 2개를 뽑는 경우의 수 더하기
for i in range(M):
    # i번 나머지를 가진 개수가 cnt라면, cnt * (cnt-1) // 2
    if remainder[i] > 1:
        answer += (remainder[i] * (remainder[i] - 1) // 2)

print(answer)
```
</details>

## 4-3. 투 포인터 (Two Pointers)

### 1. 투 포인터란?
리스트에 순차적으로 접근해야 할 때, **2개의 점(포인터)의 위치를 기록하면서 처리**하는 알고리즘입니다.
* 이중 `for`문으로 풀면 $O(N^2)$이 걸리는 문제를, 포인터 두 개를 한 번만 훑어서 **$O(N)$**에 풀게 해줍니다.
* **포인터**라고 해서 어렵게 생각할 필요 없습니다! 그냥 `start_index`, `end_index`라는 **변수 2개**를 뜻합니다.

### 2. 대표적인 이동 원칙
보통 정렬된 리스트에서 두 수의 합을 구할 때 많이 씁니다.
* **합 > 목표값:** 합을 줄여야 하므로 `end_index`를 왼쪽으로 이동 (값 감소)
* **합 < 목표값:** 합을 키워야 하므로 `start_index`를 오른쪽으로 이동 (값 증가)
* **합 == 목표값:** 카운트 증가, 포인터 이동

### [실전 문제] 2018번: 수들의 합 5
> **문제 내용** > 어떠한 자연수 N은, 몇 개의 연속된 자연수의 합으로 나타낼 수 있다. 당신은 어떤 자연수 N(1 ≤ N ≤ 10,000,000)을 몇 개의 연속된 자연수의 합으로 나타내는 가짓수를 알고 싶다. 이때, 사용하는 자연수는 N이하여야 한다.
> 예를 들어 15를 나타내는 방법은 15, 7+8, 4+5+6, 1+2+3+4+5의 4가지가 있다.
>
> **입력** > 첫 줄에 정수 N이 주어진다.
>
> **출력** > 입력된 자연수 N을 몇 개의 연속된 자연수의 합으로 나타내는 가짓수를 출력한다.

**예제 입력**
```text
15
```
**예제 출력**
```text
4
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어
* $N$이 1,000만이라서 $O(N)$으로 풀어야 합니다.
* 투 포인터 이동 전략:
    * sum > N: 왼쪽 값을 빼고 start_index를 오른쪽으로 한 칸 이동. (sum 감소)
    * sum < N: end_index를 오른쪽으로 한 칸 이동하고 값을 더함. (sum 증가)
    * sum == N: count 증가, end_index 이동.

### 📝 슈도코드
```text
1. N 입력받기
2. 사용 변수 초기화 (count=1, start=1, end=1, sum=1)
   (count=1인 이유는 자기 자신 N 하나만 뽑는 경우를 미리 포함)
3. end가 N이 될 때까지 반복:
    3-1. sum == N 인 경우:
         count 증가, end 증가, sum에 end값 더하기
    3-2. sum > N 인 경우:
         sum에서 start값 빼기, start 증가
    3-3. sum < N 인 경우:
         end 증가, sum에 end값 더하기
4. count 출력
```

### 💻 정답 코드
```python
n = int(input())

count = 1 # 자기 자신(15) 하나인 경우 미리 포함
start_index = 1
end_index = 1
sum_val = 1

while end_index != n:
    if sum_val == n:
        count += 1
        end_index += 1
        sum_val += end_index
    elif sum_val > n:
        sum_val -= start_index
        start_index += 1
    else: # sum_val < n
        end_index += 1
        sum_val += end_index

print(count)
```
</details>

### [실전 문제] 1940번: 주몽
> **문제 내용** > 갑옷을 만드는 재료들은 각각 고유한 번호를 가지고 있다. 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어진다. N(1 ≤ N ≤ 15,000)개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지 구하시오.
>
> **입력** > 첫째 줄에 재료의 개수 N, 둘째 줄에 갑옷을 만드는데 필요한 수 M, 셋째 줄에 N개의 재료들이 가진 고유한 번호들이 공백을 사이에 두고 주어진다.
>
> **출력** > 만들 수 있는 갑옷의 개수를 출력한다.

**예제 입력**
```text
6
9
2 7 4 1 5 3
```
**예제 출력**
```text
2
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어
* 무작위로 나열된 숫자들을 **정렬(Sort)**한 뒤 양쪽 끝에서 투 포인터를 좁혀오면 됩니다.
* A[i] + A[j] 값에 따라 포인터를 이동합니다.

### 📝 슈도코드
```text
1. N, M 입력받기
2. 재료 리스트 A 입력받고 정렬하기 (sort)
3. i(시작)는 0, j(끝)는 N-1로 초기화
4. i < j 동안 반복:
    4-1. A[i] + A[j] < M: 작은 쪽(i)을 키움
    4-2. A[i] + A[j] > M: 큰 쪽(j)을 줄임
    4-3. A[i] + A[j] == M: count 증가, i 증가, j 감소
5. count 출력
```

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

N = int(input())
M = int(input())
A = list(map(int, input().split()))
A.sort() # 정렬 필수!

count = 0
i = 0       # 시작 포인터 (Min)
j = N - 1   # 끝 포인터 (Max)

while i < j:
    if A[i] + A[j] < M:
        i += 1
    elif A[i] + A[j] > M:
        j -= 1
    else: # 합이 M과 같음
        count += 1
        i += 1
        j -= 1

print(count)
```
</details>

### [실전 문제] 1253번: 좋다 (Good Number)
> **문제 내용** > N개의 수 중에서 어떤 수가 **다른 수 두 개의 합**으로 나타낼 수 있다면 그 수를 “좋다(GOOD)”고 한다. N개의 수가 주어지면 그 중에서 좋은 수의 개수는 몇 개인지 출력하라.
>
> **입력** > 첫째 줄에 수의 개수 N(1 ≤ N ≤ 2,000), 둘째 줄에 N개의 수의 값.
>
> **출력** > 좋은 수의 개수.

**예제 입력**
```text
10
1 2 3 4 5 6 7 8 9 10
```
**예제 출력**
```text
8
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어 (주의사항!)
* 단순히 A[i] + A[j] == K를 찾는 게 아니라, 자기 자신을 제외한 두 수의 합이어야 합니다.
* 예: [0, 5]가 있고 5를 만들 때, 0 + 5 = 5는 되지만, 여기서 5는 자기 자신이므로 안 됩니다.
* 따라서 찾는 과정에서 인덱스가 자기 자신(k)과 겹치는지 확인해야 합니다.

### 📝 슈도코드
```text
1. N 입력, 리스트 A 정렬
2. for k in range(N): (찾으려는 타겟 수의 인덱스)
    2-1. 타겟값 find = A[k]
    2-2. i=0, j=N-1 설정
    2-3. while i < j:
        - 합 == find:
            - i나 j가 k와 같은지 확인
            - 둘 다 k가 아니면 count 증가, 종료(break)
            - i가 k면 i 증가, j가 k면 j 감소
        - 합 < find: i 증가
        - 합 > find: j 감소
```

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))
A.sort()

count = 0

for k in range(N):
    find = A[k]
    i = 0
    j = N - 1
    
    while i < j:
        if A[i] + A[j] == find:
            # 두 포인터가 타겟(k) 위치가 아닌지 확인
            if i != k and j != k:
                count += 1
                break
            elif i == k:
                i += 1
            elif j == k:
                j -= 1
        elif A[i] + A[j] < find:
            i += 1
        else:
            j -= 1

print(count)
```
</details>

## 4-4. 슬라이딩 윈도우 (Sliding Window)

### 1. 슬라이딩 윈도우란?
투 포인터와 비슷하지만, **두 포인터 사이의 간격(윈도우 크기)이 고정**되어 이동하는 알고리즘입니다.
* 창문(Window)을 밀면서(Sliding) 그 안의 데이터만 봅니다.
* 핵심은 **"들어오는 값 더하고, 나가는 값 빼기"**입니다. 매번 윈도우 안의 합을 다시 구하면 시간 초과가 납니다.

### 2. 시간 복잡도
* 배열 길이 $N$, 윈도우 크기 $M$일 때
* 일반적인 계산: 매번 더하면 $O(N \times M)$
* 슬라이딩 윈도우: 갱신만 하므로 **$O(N)$**

### [실전 문제] 12891번: DNA 비밀번호
> **문제 내용** > DNA 문자열은 'A', 'C', 'G', 'T'로만 이루어져 있다. 임의의 DNA 문자열의 부분 문자열을 비밀번호로 사용하려 한다. 단, 부분 문자열에 포함된 'A', 'C', 'G', 'T'의 최소 개수 조건이 있다. 조건을 만족하는 부분 문자열의 개수를 구하시오.
>
> **입력** > 문자열 길이 S, 부분 문자열 길이 P. 그 다음 줄에 문자열. 그 다음 줄에 A, C, G, T 최소 개수 4개.
>
> **출력** > 만들 수 있는 비밀번호의 개수.

<details>
<summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어
* 윈도우를 한 칸 오른쪽으로 밀 때:
    * **오른쪽 끝(새로 들어온 문자)**: 개수 추가 (`Add`)
    * **왼쪽 끝(빠지는 문자)**: 개수 감소 (`Remove`)
* 이렇게 갱신된 개수가 조건(`checkList`)을 만족하는지 확인합니다.

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

# 데이터 입력
S, P = map(int, input().split())
A = list(input().rstrip())
checkList = list(map(int, input().split())) # 최소 개수 [A, C, G, T]

# 현재 윈도우 상태
myList = [0] * 4 # [A, C, G, T] 개수
checkSecret = 0 # 4개의 조건을 몇 개나 만족했는지 카운트 (최대 4)

# 문자 -> 인덱스 변환 함수 (A:0, C:1, G:2, T:3)
def my_add(c):
    global checkSecret
    if c == 'A':
        myList[0] += 1
        if myList[0] == checkList[0]: checkSecret += 1
    elif c == 'C':
        myList[1] += 1
        if myList[1] == checkList[1]: checkSecret += 1
    elif c == 'G':
        myList[2] += 1
        if myList[2] == checkList[2]: checkSecret += 1
    elif c == 'T':
        myList[3] += 1
        if myList[3] == checkList[3]: checkSecret += 1

def my_remove(c):
    global checkSecret
    if c == 'A':
        if myList[0] == checkList[0]: checkSecret -= 1
        myList[0] -= 1
    elif c == 'C':
        if myList[1] == checkList[1]: checkSecret -= 1
        myList[1] -= 1
    elif c == 'G':
        if myList[2] == checkList[2]: checkSecret -= 1
        myList[2] -= 1
    elif c == 'T':
        if myList[3] == checkList[3]: checkSecret -= 1
        myList[3] -= 1

# 1. 초기 P개 문자에 대해 처리
for i in range(4):
    if checkList[i] == 0:
        checkSecret += 1

for i in range(P):
    my_add(A[i])

count = 0
if checkSecret == 4:
    count += 1

# 2. 슬라이딩 윈도우 이동
for i in range(P, S):
    j = i - P # j는 윈도우에서 빠지는 맨 왼쪽 인덱스
    my_add(A[i])    # 오른쪽 추가
    my_remove(A[j]) # 왼쪽 제거
    
    if checkSecret == 4:
        count += 1

print(count)
```
</details>

### [실전 문제] 11003번: 최솟값 찾기
> **문제 내용** > N개의 수 $A_1, A_2, ..., A_N$과 L이 주어진다. $D_i = A_{i-L+1} \sim A_i$ 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오.
>
> **입력** > N, L. 둘째 줄에 N개의 수.
>
> **출력** > $D_1$부터 $D_N$까지 공백으로 구분해 출력.

<details>
<summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어 (덱 Deque 활용)
* 단순히 범위 내 최솟값을 매번 찾으면 시간 초과($O(N \times L)$)입니다.
* **덱(Deque)**을 이용하여 정렬 효과를 냅니다.
* 덱에는 **(인덱스, 값)** 형태를 저장합니다.
* **규칙:**
    1. 덱의 마지막 값보다 들어올 값이 작으면, 마지막 값을 제거(`pop()`) -> **오름차순 유지**
    2. 들어올 값을 덱에 추가.
    3. 덱의 맨 앞(최솟값) 인덱스가 윈도우 범위를 벗어났으면 제거(`popleft()`).
    4. 덱의 맨 앞 값이 현재 윈도우의 최솟값임.

### 💻 정답 코드
```python
from collections import deque
import sys
input = sys.stdin.readline

N, L = map(int, input().split())
now = list(map(int, input().split()))

mydeque = deque()

# i: 현재 윈도우의 끝 인덱스
for i in range(N):
    # 1. 나보다 큰 값들은 덱에서 제거 (최솟값이 될 가능성 없음)
    while mydeque and mydeque[-1][0] > now[i]:
        mydeque.pop()
    
    # 2. 현재 값 추가 (값, 인덱스) -> 책에서는 (값, 인덱스) 순서 주의
    mydeque.append((now[i], i))
    
    # 3. 윈도우 범위를 벗어난 앞쪽 값 제거
    # 현재 인덱스 i에서 L만큼 뺀 것보다 인덱스가 작으면 범위 밖
    if mydeque[0][1] <= i - L:
        mydeque.popleft()
        
    # 4. 최솟값 출력 (덱의 맨 앞)
    print(mydeque[0][0], end=' ')
```
</details>

## 4-5. 스택과 큐 (Stack & Queue)

### 1. 스택 (Stack)
* **개념:** 선입후출 (LIFO: Last In First Out). 박스를 쌓는 것처럼 나중에 넣은 것이 먼저 나옵니다.
* **파이썬 구현:** 별도의 모듈 없이 **기본 리스트(`[]`)**를 사용합니다.
* **주요 함수:**
    * `s.append(data)`: 데이터 삽입 (Push)
    * `s.pop()`: 맨 위 데이터 꺼내기 및 삭제 (Pop)
    * `s[-1]`: 맨 위 데이터 확인 (Top/Peek) - *삭제하지 않음*

### 2. 큐 (Queue)
* **개념:** 선입선출 (FIFO: First In First Out). 줄 서기처럼 먼저 들어간 것이 먼저 나옵니다.
* **파이썬 구현:** `collections` 모듈의 **`deque`**를 사용합니다. (리스트의 `pop(0)`은 느려서 시간 초과가 발생합니다.)
* **주요 함수:**
    * `q.append(data)`: 데이터 삽입 (Enqueue)
    * `q.popleft()`: 맨 앞 데이터 꺼내기 및 삭제 (Dequeue)
    * `q[0]`: 맨 앞 데이터 확인 - *삭제하지 않음*

### 3. 우선순위 큐 (Priority Queue)
* **개념:** 들어간 순서와 상관없이 **우선순위가 높은(보통 값이 작은)** 데이터가 먼저 나옵니다.
* **파이썬 구현:** `heapq` 모듈 사용 (최소 힙 구조).

### [실전 문제] 1874번: 스택 수열
> **문제 내용** > 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.
>
> **입력** > 첫 줄에 n (1 ≤ n ≤ 100,000). 둘째 줄부터 n개의 줄에 수열을 이루는 1이상 n이하의 정수가 하나씩 주어진다.
>
> **출력** > 입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push연산은 +, pop연산은 -로 표현한다. 불가능한 경우 NO를 출력한다.

**예제 입력**
```text
8
4
3
6
8
7
5
2
1
```
**예제 출력**
```text
+
+
+
+
-
-
+
+
-
+
+
-
-
-
-
-
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어
* 자연수는 1부터 N까지 순서대로만 증가하며 넣을 수 있습니다. (count 변수 활용)
* 현재 수열 값 >= 오름차순 자연수: 같해질 때까지 push(+)하고, 같아지면 pop(-).
* 현재 수열 값 < 오름차순 자연수: 스택의 맨 위(top)가 현재 수열 값과 같으면 pop(-). 만약 다르면? -> 불가능(NO)

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
stack = []
answer = [] # +, - 를 저장할 리스트
flag = True
cur = 1 # 현재 스택에 넣을 차례인 자연수 (1부터 시작)

for _ in range(n):
    target = int(input()) # 만들어야 하는 수열의 숫자
    
    # 1. target이 될 때까지 스택에 넣기 (Push)
    while cur <= target:
        stack.append(cur)
        answer.append('+')
        cur += 1
        
    # 2. 스택의 top이 target과 같은지 확인
    if stack[-1] == target:
        stack.pop()
        answer.append('-')
    else:
        # 스택의 top이 target보다 크면 불가능한 경우임
        print("NO")
        flag = False
        break

if flag:
    for i in answer:
        print(i)
```
</details>

### [실전 문제] 17298번: 오큰수
> **문제 내용** > 크기가 N인 수열 $A = A_1, A_2, ..., A_N$이 있다. 각 원소 $A_i$에 대해서 오큰수 $NGE(i)$를 구하려고 한다. $A_i$의 오큰수는 오른쪽에 있으면서 $A_i$보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.
>
> **입력** > 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000). 둘째 줄에 수열 A의 원소들이 주어진다.
>
> **출력** > 총 N개의 오큰수를 공백으로 구분해 출력한다.

**예제 입력**
```text
4
3 5 2 7
```
**예제 출력**
```text
5 7 7 -1
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어 (모노톤 스택)
* $N$이 백만이라 이중 반복문($O(N^2)$)은 시간 초과입니다. 스택을 이용해 $O(N)$으로 풉니다.
* 스택에는 **'아직 오큰수를 못 찾은 수의 인덱스'**를 저장합니다.
* 새로 들어온 수(A[i])가 스택의 top에 해당하는 수(A[stack[-1]])보다 크다면?
    * 그 top의 오큰수는 바로 A[i]입니다!
    * 스택에서 pop하고 정답을 기록합니다. (반복)

### 💻 정답 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
A = list(map(int, input().split()))
ans = [-1] * n # 정답 배열 (-1로 초기화)
stack = [] # 인덱스를 저장하는 스택

for i in range(n):
    # 스택이 비어있지 않고, 현재 수 A[i]가 스택 top의 수보다 크면
    # -> 오큰수를 찾은 것!
    while stack and A[stack[-1]] < A[i]:
        index = stack.pop()
        ans[index] = A[i]
    
    # 현재 인덱스를 스택에 넣음 (오큰수를 기다림)
    stack.append(i)

print(*ans) # 리스트 언패킹하여 출력
```
</details>

### [실전 문제] 2164번: 카드2
> **문제 내용** > N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.
> 이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.
> 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.
>
> **입력** > 첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.
>
> **출력** > 첫째 줄에 남게 되는 카드의 번호를 출력한다.

**예제 입력**
```text
6
```
**예제 출력**
```text
4
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어 (큐 활용)
* "맨 위를 버린다" -> popleft()
* "맨 위를 아래로 옮긴다" -> popleft() 한 값을 다시 append()
* 반드시 collections.deque를 써야 시간 초과가 나지 않습니다.

### 💻 정답 코드
```python
from collections import deque
import sys
input = sys.stdin.readline

N = int(input())
myQueue = deque()

# 1부터 N까지 카드 채우기
for i in range(1, N + 1):
    myQueue.append(i)

while len(myQueue) > 1: # 카드가 1장 남을 때까지
    myQueue.popleft() # 1. 맨 위 버리기
    myQueue.append(myQueue.popleft()) # 2. 맨 위를 아래로 옮기기

print(myQueue[0])
```
</details>

### [실전 문제] 11286번: 절댓값 힙
> **문제 내용** > 절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.
> 1. 배열에 정수 x (x ≠ 0)를 넣는다.
> 2. 배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.
>
> **입력** > 연산의 개수 N. 다음 N개의 줄에 정수 x가 주어진다. x가 0이 아니면 추가, 0이면 출력 및 제거이다.
>
> **출력** > 0이 입력될 때마다 절댓값이 가장 작은 값을 출력한다. (비어있으면 0 출력)

**예제 입력**
```text
18
1
-1
0
0
0
1
1
-1
-1
2
-2
0
0
0
0
0
0
0
```
**예제 출력**
```text
-1
1
0
-1
-1
1
1
-2
2
0
```
<details> <summary>✅ <b>정답 코드 및 해설 보기 (클릭)</b></summary>

### 💡 핵심 아이디어 (우선순위 큐와 튜플)
* 파이썬의 heapq는 기본적으로 **최소 힙(Min Heap)**입니다. (작은 숫자가 먼저 나옴)
* 절댓값 기준으로 정렬하려면, 힙에 넣을 때 데이터를 변형해서 튜플 (절댓값, 원래값) 형태로 넣습니다.
* 튜플은 첫 번째 요소끼리 비교하고, 같으면 두 번째 요소끼리 비교하므로 문제의 조건(절댓값 같으면 작은 수 우선)을 완벽히 만족합니다.

### 💻 정답 코드
```python
import heapq
import sys
input = sys.stdin.readline

N = int(input())
myHeap = []

for _ in range(N):
    x = int(input())
    
    if x == 0:
        if not myHeap: # 힙이 비어있으면
            print(0)
        else:
            # (절댓값, 원래값) 중 원래값만 출력
            print(heapq.heappop(myHeap)[1])
    else:
        # (절댓값, 원래값) 순서로 튜플 저장
        heapq.heappush(myHeap, (abs(x), x))
```
</details>