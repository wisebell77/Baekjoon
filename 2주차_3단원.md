# [3단원] 미리 보는 코딩 테스트 오답 노트 & 필수 문법

> **강의 목표**
> 코딩 테스트 입문자가 가장 많이 실수하는 시간 초과, 인덱스 활용, 정렬, 2차원 배열의 기초를 탄탄히 다집니다.
> 단순히 '쓰는 법'을 넘어 **'왜 이렇게 동작하는지'** 원리를 이해해 봅시다.

---

## 3-1. 시간 초과의 원인을 찾아 해결하기 (입출력 가속)

코딩 테스트에서 알고리즘이 맞는데 **시간 초과(Time Limit Exceeded)**가 난다면, 가장 먼저 **입출력 방식**을 의심해야 합니다.

### 1. `input()` vs `sys.stdin.readline()`
파이썬의 기본 `input()`은 사용자 친화적이지만 느립니다. 반면 `sys` 모듈은 버퍼에서 날것의 데이터를 읽어오기 때문에 훨씬 빠릅니다.

| 기능 | `input()` | `sys.stdin.readline()` |
| :--- | :--- | :--- |
| **작동 원리** | 1. 입력을 받음<br>2. 개행 문자(`\n`) 삭제 처리<br>3. 프롬프트 메시지 출력 기능 포함 | 1. 버퍼에서 한 줄을 통째로 읽음<br>2. 별도 처리 없이 그대로 반환 (개행 문자 포함) |
| **속도** | 느림 (입력 데이터가 10만 개 이상이면 치명적) | **매우 빠름** (대량의 데이터 처리에 필수) |
| **사용처** | 간단한 예제, 대화형 프로그램 | **코딩 테스트**, 알고리즘 문제 풀이 |

### 2. 사용 예시 및 주의점

```python
import sys

# [Bad] 데이터가 10만 개라면 시간 초과 가능성 높음
# n = input() 

# [Good] 관용적으로 사용하는 빠른 입력
# readline은 끝에 '\n'이 붙으므로 .rstrip()으로 제거해주는 것이 좋음
data = sys.stdin.readline().rstrip()
print(f"입력받은 데이터: {data}")
```
### 3. print() vs sys.stdout.write()
* print(): 자동으로 줄바꿈을 해주고, 내부적으로 문자열 변환 등의 처리가 있어 오버헤드가 있습니다.
* sys.stdout.write(): 줄바꿈 없이 문자열만 버퍼에 씁니다. 단, 문자열(str)만 출력 가능하므로 숫자는 str()로 변환해야 합니다.
* 참고: 파이썬(PyPy3)에서는 print만 써도 충분한 경우가 많으나, 출력이 수십만 줄일 때는 sys.stdout.write를 고려해야 합니다.

---
## 3-2. 인덱스에 의미 부여하여 풀어 보기 (해싱 개념)

배열(리스트)의 인덱스는 단순한 '순서'가 아니라 '데이터 그 자체'가 될 수 있습니다. 이를 활용하면 탐색 속도를 $O(N)$에서 $O(1)$로 획기적으로 줄일 수 있습니다.

### 핵심 아이디어: 직접 주소 테이블 (Direct Addressing)
* **일반적인 생각:** "리스트 안에 숫자 5가 있는지 찾아보자." (처음부터 끝까지 뒤져야 함)
* **인덱스 활용:** "리스트의 5번 인덱스에 체크 표시가 되어 있는지 보자." (즉시 확인 가능)

### 예시: 알파벳 빈도수 세기
문자열에서 각 알파벳이 몇 번 나왔는지 셀 때, 딕셔너리를 쓸 수도 있지만 리스트 인덱스를 활용하면 더 빠를 수 있습니다.

```python
word = "algorithm"
count = [0] * 26  # a~z까지 26개의 공간 생성

for char in word:
    # ord('a')는 97. 'a'를 0번 인덱스로 매핑
    index = ord(char) - ord('a') 
    count[index] += 1

print(count) 
# 인덱스 0은 'a'의 개수, 인덱스 1은 'b'의 개수...
```
---
## 3-3. 나머지 연산의 중요성 (모듈러 연산)

큰 수의 연산, 주기(Cycle)가 있는 문제, 암호학 등에서 나머지 연산(`%`)은 필수입니다.

### 1. 나머지 연산의 분배 법칙
큰 수를 다룰 때, 계산 중간중간 나머지를 구해도 결과는 같습니다. 이는 **오버플로우(Overflow)** 방지에 매우 중요합니다.

$$(A + B) \% C = ((A \% C) + (B \% C)) \% C$$
$$(A \times B) \% C = ((A \% C) \times (B \% C)) \% C$$

> **[심화] 덧셈 분배 법칙 증명**
> 
> $A$와 $B$를 $C$로 나눈 몫을 각각 $q_1, q_2$, 나머지를 $r_1, r_2$라고 가정합시다.
> * $A = q_1C + r_1$
> * $B = q_2C + r_2$
>
> 이때, $A + B$를 해보면:
> $$A + B = (q_1C + r_1) + (q_2C + r_2)$$
> $$A + B = C(q_1 + q_2) + (r_1 + r_2)$$
>
> 여기서 $(A+B)$를 $C$로 나눈 나머지는 $C(q_1+q_2)$ 부분은 $C$의 배수이므로 사라지고, 결국 **$(r_1 + r_2)$를 $C$로 나눈 나머지**와 같아집니다.
> 즉, 처음부터 나머지($r_1, r_2$)끼리 더해서 다시 나눠도 결과는 같습니다.

### 2. 활용 팁
* 문제에서 "정답을 1,000,000,007로 나눈 나머지를 출력하라"는 문구가 있다면, **마지막에만 `%` 하지 말고 모든 연산마다 `%`를 해주는 것**이 안전합니다.

---
## 3-4. 정렬 기초 다지기

파이썬은 **Timsort**라는 매우 강력하고 효율적인 정렬 알고리즘($O(N \log N)$)을 내장하고 있습니다.

### 1. `sort()` vs `sorted()`
가장 많이 헷갈리는 두 함수의 차이점입니다.

| 구분 | `list.sort()` | `sorted(iterable)` |
| :--- | :--- | :--- |
| **반환값** | `None` (반환값이 없음) | **정렬된 새로운 리스트** 반환 |
| **원본 데이터** | **변경됨** (In-place sort) | **변경되지 않음** (원본 유지) |
| **사용 객체** | 리스트(List) 전용 | 리스트, 튜플, 문자열 등 모든 반복 가능 객체 |

```python
# 예시
arr = [3, 1, 2]
result = sorted(arr) 

print(arr)    # [3, 1, 2] (원본은 그대로)
print(result) # [1, 2, 3] (정렬된 새 리스트)

arr.sort()
print(arr)    # [1, 2, 3] (원본이 변경됨)
```
### 2. 기타 정렬 알고리즘(개념만)
* **버블/선택/삽입 정렬**: 구현이 쉽지만 느림 ($O(N^2)$). 학습 목적으로만 사용.
* **퀵/병합/힙 정렬**: 빠름 ($O(N \log N)$). 파이썬 내부 라이브러리가 이미 최적화되어 있으므로 직접 구현할 일은 드뭅니다.
---
## 3-5. 다중 조건 정렬 익히기

"길이가 짧은 순으로, 길이가 같다면 사전 순으로 정렬하세요."와 같이 조건이 여러 개일 때 해결하는 방법입니다.

### 1. 튜플(Tuple)을 이용한 정렬
파이썬의 튜플 비교 방식은 **첫 번째 요소를 비교하고, 같으면 두 번째 요소를 비교**하는 식입니다. 이를 이용해 정렬 우선순위를 지정합니다.

```python
words = ["apple", "bat", "cat", "ant"]

# 조건 1: 길이(len) -> 오름차순
# 조건 2: 단어 자체(사전 순) -> 오름차순
words.sort(key=lambda x: (len(x), x))
print(words) 
# 결과: ['bat', 'cat', 'ant', 'apple'] 
# (길이 3인 것들 먼저, 그 안에서 사전 순)
```
### 2. 딕셔너리 기반 정렬 vs 튜플 기반 정렬
* **튜플 기반 (lambda):** `key` 인자에 `lambda` 함수를 써서 튜플을 반환하게 하는 방식이 가장 일반적이고 간결합니다.
* **딕셔너리 정렬:** 딕셔너리(`dict.items()`)를 리스트로 변환하여 정렬합니다.

| 방식 | 특징 | 장점 | 단점 |
| :--- | :--- | :--- | :--- |
| **Lambda + 튜플** | `key=lambda x: (x[0], -x[1])` | 코드가 짧고 직관적. `-`를 붙여 내림차순 혼합 가능(숫자일 때). | 람다 문법이 처음엔 낯설 수 있음. |
| **Itemgetter** | `from operator import itemgetter` | 실행 속도가 람다보다 미세하게 빠름. | 별도 모듈 import 필요. |

**Tip:** 문자열 내림차순 등 `-`를 붙일 수 없는 경우(문자열엔 마이너스가 안 붙음), `reverse=True`를 쓰거나 비교 함수를 따로 정의해야 합니다.

---
## 3-6. 이차원 리스트 제대로 다루기 (그래프)

코딩 테스트의 꽃, **DFS/BFS/그래프** 문제를 풀기 위해서는 2차원 리스트(행렬)를 자유자재로 다뤄야 합니다.

### 1. 선언과 초기화 (주의!!)
초심자가 가장 많이 하는 실수: **얕은 복사(Shallow Copy)** 문제

```python
# [Bad] 이렇게 하면 안 됩니다! 절대 금지!
n, m = 3, 4
graph = [[0] * m] * n 

# [이유] 
# 모든 행이 같은 메모리 주소를 공유하게 됨.
# graph[0][0] = 1을 하면 graph[1][0], graph[2][0]도 다 1로 변해버림.

# [Good] 리스트 컴프리헨션 사용 (각 행을 새로 생성)
graph = [[0] * m for _ in range(n)]
```
### 2. 그래프 데이터 저장하기 (인접 행렬 vs 인접 리스트)
문제에서 정점(Node)과 간선(Edge)이 주어졌을 때 저장하는 방법입니다.

* **인접 행렬 (2차원 배열):** 공간을 많이 차지하지만(`N*N`), 두 노드 간 연결 확인이 빠름(`O(1)`). 노드 개수가 적을 때(보통 1,000개 이하) 사용.
    ```python
    # 노드 1과 노드 2가 연결됨
    graph[1][2] = 1
    graph[2][1] = 1 # 무방향 그래프일 경우
    ```
* **인접 리스트 (실무/코테 선호):** 연결된 정보만 저장. 메모리 효율적. 노드 개수가 많을 때 사용.
    ```python
    graph = [[] for _ in range(N + 1)]
    graph[1].append(2)
    graph[2].append(1)
    ```

### 3. 그래프 데이터 가져오기
2차원 리스트 탐색은 보통 이중 `for`문을 사용합니다.

```python
for r in range(n):      # 행(Row) 탐색
    for c in range(m):  # 열(Col) 탐색
        print(graph[r][c], end=' ')
    print()
```